# 클로저

## 러버덕 내용 정리
MDN는 클로저란 함수와 함수가 선언된 렉시컬 환경과의 조합이라고 정의하고 있습니다. 즉 모든 함수는 클로저라 할 수 있습니다

하지만 실용적으로 클로저를 사용하기 위해 아래 2가지 조건을 충족하는 함수를 모던 환경에서는 클로저라 합니다
- 1. 내부 함수의 실행 컨텍스트가 외부 함수의 실행 컨텍스트보다 오래 실행컨텍스트 스택에 유지되어야 합니다
- 2. 내부 함수가 외부 함수의 식별자를 참조해야 합니다

이때 내부 함수(클로저)에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 합니다

클로저의 동작원리를 이해하기 위해서는 실행 컨텍스트와 렉시컬 환경에 대해 이해할 필요가 있는데 실행 컨텍스트는 해당 스코프의 소스 코드가 전부 실행되면 실행 컨텍스트 스택에서 pop 되는 반면 렉시컬 환경은 더 이상 참조되지 않을때 메모리에서 해제되게 됩니다. 따라서 클로저는 위 2가지 조건을 충족할 때 외부 함수의 실행 컨텍스트가 pop 되더라도 내부 함수는 외부 함수의 렉시컬 환경을 참조 가능합니다

함수가 렉시컬 환경을 참조하는 매커니즘에 대해서도 알 필요가 있는데, 함수는 함수 객체가 생성될 때(즉 함수 정의가 위치하는 스코프가 평가 또는 실행되고 있는 시점) 실행중인 실행 컨텍스트의 렉시컬 환경을 함수의 내부 슬롯인 [[Environment]]에 참조값으로 저장합니다. 이때 내부 슬롯 [[Environmnet]]에 저장한 렉시컬 환경의 참조값인 상위 스코프는 변하지 않습니다. 때문에 외부 함수의 실행 컨텍스트가 먼저 pop 되더라도 내부 함수의 내부 슬롯 [[Environment]]에 의해 참조되고 있기 때문에 외부 함수의 렉시컬 환경은 메모리에서 해제되지 않습니다

하지만 모던 환경에서의 클로저는 최적화를 위해 위의 2가지 조건을 충족하지 않는다면 내부 슬롯 [[Environment]]에서 렉시컬 환경을 참조하더라도 메모리에서 해제합니다

클로저는 상태를 안전하게 은닉하고 특정 함수(클로저)에게만 상태 변경을 허용하기 위해 사용합니다

클로저는 외부함수는 즉시 실행 함수로 만들고 자유변수는 외부함수인 즉시실행 함수에 속하며 내부 함수는 외부 함수의 return 문의 반환값으로 정의되어 내부 함수의 실행 컨텍스트가 외부 함수의 실행 컨텍스트보다 더 오래 유지되게 하는것이 일반적인 클로저의 형태입니다

함수는 호출시마다 평가되기(실행 컨텍스트를 생성하기)때문에 같은 렉시컬 환경을 공유하는 클로저를 만들기 위해서는 함수는 한번만 호출되어야 합니다

캡슐화는 프로퍼티와 메서르를 하나로 묶는것을 말하며 기본적으로 객체의 모든 프로퍼티와 메서드는 public 합니다

for 문의 변수 선언문에서 let 키워드로 선언한 변수를 사용하면 for 문의 코드 블록이 반복 실행될때마다 새로운 렉시컬 환경이 생성됩니다. 이는 let 키워드로 선언한 변수가 전역 객체에 저장되지 않고 선언적 환경 레코드에 저장되기 때문입니다