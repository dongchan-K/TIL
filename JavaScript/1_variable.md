# 변수

### 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다

**예시**

```js
var result = 10 + 20;
```

![값의 생성과 변수 할당](https://user-images.githubusercontent.com/67866773/91003249-c0174280-e60b-11ea-9fc4-94f194772507.png)

- 위 예시의 `result`를 **변수 이름** `10+ 20`을 **변수 값**이라고 하며, 변수에 값을 저장하는 것을 **할당(assignment 대입,저장)** 이라 하고 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)** 라 한다

- **변수 이름**을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다

- **변수 이름** 은 메모리 공간에 저장된 값을 식별할 수 있는 이름을 뜻하며,
 저장된 값의 의미를 명확히 할 수 있기 때문에 개발자의 의도를 나타내는 명확한 네이밍을 할 필요가 있다

  - 올바른 변수 이름 예시

    ```js
    var password = 123456;
    var userName = 'Dong-chan';
    ```

- **변수(variable)** 는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다

## 메모리

### 메모리는 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합체이다

- **메모리 셀** 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장(write)하거나 읽어(read)들인다

- 각 셀은 고유의 **메모리 주소(memory address)** 를 갖는다. 이 메모리 주소는 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 수 있기 때문에 자바스크립트는 개발자의 직접적인 메모리의 제어를 허용하지 않는다

## 식별자

### 변수 이름을 식별자(identifier)라고도 하며, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다

**예시**

![식별자](https://user-images.githubusercontent.com/67866773/91005196-42eecc00-e611-11ea-93b5-6c7a057e39e9.png)

- 변수, 함수, 클래스 등의 이름은 모두 식별자이다

- 식별자는 값이 아니라 메모리 주소를 기억하고 있다

## 식별자 네이밍

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호(\$)를 포함할 수 있다

- 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호(\$)로 시작해야 한다

- **예약어** 는 식별자로 사용할 수 없다

  - **예약어** : 프로그래밍 언어에서 사용되고 있거나 사용예정인 언어들을 말한다

**자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다**

```js
// 카멜 케이스 (camelCase)
var firstName;
// 파스칼 케이스 (PascalCase)
var FirstName;
```
## 변수 선언

### 변수 선언은 변수 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다

```js
var score;
let score;
const score;
```

- 변수를 선언할 때는 위와 같이 `var, let, const` **키워드** 를 사용한다
  
  - **키워드** : 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어, `var` 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다

- 자바스크립트 엔진은 변수 선언을 다음 2단계에 거쳐 수행한다

  - 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다

  - 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined` 를 할당해 초기화한다

- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다 

**예시**

![변수 선언](https://user-images.githubusercontent.com/67866773/91006095-6e72b600-e613-11ea-8036-265936f5717c.png)

위와 같이 `var` 키워드로 변수를 선언한 이후, 아직 값을 할당하지 않았지만 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화된다

- 일반적으로 초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. `var` 키워드로 선언한 변수는 `undefined`로 암묵적인 초기화가 자동 수행된다. 따라서 `var` 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다. 즉, `var` 키워드는 선언과 초기화가 런타임 이전에 수행된다
- 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이를 쓰레기 값(garbage value)라고 한다

## 변수 호이스팅

**예시**

```js
console.log(score); // undefined
var score; // 변수 선언문
```

- **변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문에** 변수 선언이 소스코드의 어디에 있던 상관없이 다른 코드보다 먼저 실행한다

- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅(variable hoisting)** 이라 한다

**`let` `const` 변수 호이스팅 동작 예시**

```js
var foo = 1;
{
  console.log(foo); // 1
  var foo = 2; // 변수 호이스팅 발생하여 변수 선언과 변수 초기화 실행
  console.log(foo); // 2
}

const foo = 1;
{
  console.log(foo); // ReferenceError
  const foo = 2; // 변수 호이스팅 발생하여 참조 에러를 유발 -> 변수 선언만 되고 변수 초기화는 실행되지 않았기 때문
}

let foo = 1;
{
  console.log(foo); // ReferenceError
  let foo = 2; // 변수 호이스팅 발생하여 참조 에러를 유발 -> 변수 선언만 되고 변수 초기화는 실행되지 않았기 때문
}
```

- 위와 같이 `let` , `const` 키워드로 선언한 변수의 경우 참조 에러(ReferenceError)가 발생하며, 호이스팅이 실제로는 발생하지만 동작은 호이스팅이 발생하지 않는 것처럼 동작한다

## 값의 할당

- 변수에 값을 할당(대입,저장)할 때는 할당 연산자(=)를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다

**변수 선언은 소스코드가 순차적으로 실행되는 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다**

**예시**

```js
console.log(score); // undefined
var score; // 변수 선언
score = 80; // 값의 할당
console.log(score); // 80
```

![값의 할당](https://user-images.githubusercontent.com/67866773/91007326-9c0d2e80-e616-11ea-910e-25764152f141.png)

## 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다

- `var` 키워드로 선언한 변수는 값을 재할당할 수 있다

**값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 상수라 한다**

- `const` 키워드는 상수이다

**예시**

```js
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

![값의 재할당](https://user-images.githubusercontent.com/67866773/91007946-2efa9880-e618-11ea-957f-158aa6605849.png)

- 위 이미지에서 `undefined` 와 `80`이라는 값은 더이상 필요하지 않은 값이다. 이런 불필요한 값들은 **가비지 콜렉터** 에 의해 메모리에서 자동 해제된다

  - **가비지 콜렉터** : 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능을 말한다. 더 이상 사용되고 있지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가바지 콜렉터를 통해 메모리 누수(memory leak)를 방지한다

## 강의 내용 요약

- 메모리 공간에는 '값'만 저장할 수 있다
- 변수 이름은 개발자를 위해 존재하며, 변수 이름을 통해 변수 값이 저장된 메모리 주소에 접근할 수 있다
- 변수 호이스팅은 변수 선언문이 런타임 이전에 실행되기 때문에 발생하는 현상이다. 코드 작성시 항상 주의할 것
- 자바스크립트는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는 매니지드 언어이다
