<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Todos</title>
  <style>
    .container {
      width: 300px;
      margin: 30px auto;
    }

    .todos {
      list-style-type: none;
      padding: 0;
    }

    .todos>li>label>span {
      display: inline-block;
      width: 120px;
      padding: 0 10px;
    }

    /* 체크된 텍스트에 밑줄 긋기 */
    .todos>li>label>input[type='checkbox']:checked+span {
      text-decoration: line-through;
    }
  </style>
</head>

<body>
  <div class='container'>
    <input class='input-todo' type='text' name='foo' placeholder='enter todo!'' />
    <button class=' add'>add</button>
    <ul class='todos'>

    </ul>
  </div>
  <script>
    /* eslint-disable */

    //States
    let todos = [];
    // Doms
    const $todos = document.querySelector('.todos');
    const $inputTodo = document.querySelector('.input-todo');
    const $add = document.querySelector('.add');


    // 로딩 이벤트 핸들러
    const fetchTodos = () => {
      return [...[{
          id: 1,
          content: 'HTML',
          completed: false
        },
        {
          id: 2,
          content: 'CSS',
          completed: true
        },
        {
          id: 3,
          content: 'Javascript',
          completed: false
        }
      ].sort(sorter('id')).reverse()]
      // id 순서로 정렬하기 위한 sort 배열 메서드 -> 내림차순으로 바꾸기 위해서 reverse 메서드로 반전
    };

    // 숫자를 정렬하기 위한 콜백 함수 sorter
    const sorter = (key) => (a, b) => a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0);


    // render 이벤트 핸들러
    const render = () => {
      // $todos 노드는 todos 배열을 할당받기 때문에 상태를 유지할 수 있음
      $todos.innerHTML = todos.map(todo =>
        `<li id="${todo.id}">
              <label>
                <input type="checkbox" ${todo.completed ? 'checked' : ''} />
                  <span>${todo.content}</span>
                </label>
              <button class="remove">X</button>
            </li>`
      ).join('');
    };


    // addTodo 이벤트 핸들러
    const addTodo = content => {
      // todos 배열에 추가된 요소들의 id 를 할당하기 위한 변수 maxValue 
      const maxValue = todos.reduce((curr, todo) => todo.id > curr ? todo.id : curr, 0)
      todos = [{
        // id에 maxValue + 1 (현재 최대값 보다 1 큰 수) 할당
        id: maxValue + 1,
        content,
        completed: false
      }, ...todos];
    };


    // 로딩 이벤트
    window.addEventListener('DOMContentLoaded', () => {
      todos = fetchTodos();
      render();
    });


    // 입력창 이벤트
    $inputTodo.onkeyup = e => {
      if (e.key !== 'Enter' || !$inputTodo.value) return;
      addTodo($inputTodo.value);
      $inputTodo.value = '';
      render();
    };


    // 체크박스 이벤트
    $todos.onchange = e => {
      // todos 배열의 complete 프로퍼티 값을 변경하기 위한 순회
      todos.forEach(todo => {
        // li의 id(문자열이기 때문에 +기호로 숫자로 변경)와 todos 배열 요소 todo의 id 가 일치하면 실행될 조건문 
        if (+e.target.parentNode.parentNode.id === todo.id) {
          // todos 배열 요소 todo 의 completed 프로퍼티 값을 e.target(input)의 checked 로 할당
          todo.completed = e.target.checked;
        }
      })
    }


    // add 버튼 이벤트
    $add.onclick = e => {
      // 입력창 input 에 값이 없다면 반환
      if (!$inputTodo.value) return;
      // addTodo 이벤트 핸들러의 매개변수 content에 $inputTodo.value 를 인수로 전달
      addTodo($inputTodo.value);
      $inputTodo.value = '';
      // reder 이벤트 핸들러 호출 (todos 배열을 기준으로 다시 그리기)
      render();
      // add 버튼 클릭 후 입력창 input으로 포커스 이동
      $inputTodo.focus();
    }


    // remove 버튼 이벤트
    $todos.onclick = e => {
      // $todos(ul) 에 이벤트를 주어 위임했기 때문에 button 요소가 아니라면 반환하기 위한 조건문
      if(!e.target.classList.contains('remove')) return;
      // todos 배열에 li의 id와 todo의 id가 일치하지 않는 요소들만 할당
      todos = todos.filter(todo => +e.target.parentNode.id !== todo.id)
      // render 이벤트 핸들러 호출 (todos 배열을 기준으로 다시 그리기)
      render()
    }
   
  </script>
</body>

</html>
